\font\sixteen=cmbx15
\font\twelve=cmr12
\font\fonteautor=cmbx12
\font\fonteemail=cmtt10
\font\twelvenegit=cmbxti12
\font\twelvebold=cmbx12
\font\trezebold=cmbx13
\font\twelveit=cmsl12
\font\monodoze=cmtt12
\font\it=cmti12
\voffset=0,959994cm % 3,5cm de margem superior e 2,5cm inferior
\parskip=6pt

\def\titulo#1{{\noindent\sixteen\hbox to\hsize{\hfill#1\hfill}}}
\def\autor#1{{\noindent\fonteautor\hbox to\hsize{\hfill#1\hfill}}}
\def\email#1{{\noindent\fonteemail\hbox to\hsize{\hfill#1\hfill}}}
\def\negrito#1{{\twelvebold#1}}
\def\italico#1{{\twelveit#1}}
\def\monoespaco#1{{\monodoze#1}}

\long\def\abstract#1{\parshape 10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Abstract: }\twelveit #1}}

\def\resumo#1{\parshape  10 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
0.8cm 13.4cm 0.8cm 13.4cm 0.8cm 13.4cm
\noindent{{\twelvenegit Resumo: }\twelveit #1}}

\def\secao#1{\vskip12pt\noindent{\trezebold#1}\parshape 1 0cm 15cm}
\def\subsecao#1{\vskip12pt\noindent{\twelvebold#1}}
\def\subsubsecao#1{\vskip12pt\noindent{\negrito{#1}}}
\def\referencia#1{\vskip6pt\parshape 5 0cm 15cm 0.5cm 14.5cm 0.5cm 14.5cm
0.5cm 14.5cm 0.5cm 14.5cm {\twelve\noindent#1}}

%@* .

\twelve
\vskip12pt
\titulo{Interface Weaver para Formato WAVE}
\vskip12pt
\autor{Thiago Leucz Astrizi}
\vskip6pt
\email{thiago@@bitbitbit.com.br}
\vskip6pt

\abstract{This article presents the implementation of support for the
WAVE audio format in the Weaver Game Engine. In accordance with the
engine's modular design, proper support for the WAVE format requires
the definition of an extraction function that reads the audio file,
obtains auxiliary functions for memory allocation and deallocation,
and populates a sound structure with an OpenAL audio buffer.}


\vskip 0.5cm plus 3pt minus 3pt

\resumo{Este artigo apresenta a implementação do suporte ao formato de
áudio WAVE no motor de jogos Weaver. Em conformidade com o design
modular do motor, o suporte adequado ao formato WAVE requer a
definição de uma função de extração que leia o arquivo de áudio,
obtenha funções auxiliares para alocação e desalocação de memória e
preencha uma estrutura de som com um buffer de áudio do OpenAL.}

\secao{1. Introdução}

O formato WAVE é um dos muitos tipos existentes do chamado formato
RIFF. Todo arquivo no formato RIFF representa uma sequência de dados
genérica empacotada. O WAVE em específico, é feito para empacotar
arquivos de áudio.

Nosso objetivo neste artigo é definir a função de carregamento com a
assinatura abaixo:

@<Declaração de Função (wave.h)@>=
void _extract_wave(void *(*permanent_alloc)(size_t),
                   void (*permanent_free)(void *),
                   void *(*temporary_alloc)(size_t),
                   void (*temporary_free)(void *),
                   void (*before_loading_interface)(void),
                   void (*after_loading_interface)(void),
                   char *source_filename, void *interface);
@

Uma função com essa assinatura é usada no motor de jogos Weaver para
interpretar arquivos de áudio. O objetivo da função é preencher a
estrutura indicada pelo último ponteiro recebido como parâmetro. A
descrição desta estrutura pode ser importada incluindo o cabeçalho
específico do motor de jogos Weaver:

@<Cabeçalhos Locais (wave.c)@>=
#include "interface.h"
@

A saber, a estrutura tem a seguinte forma:

\alinhaverbatim
struct sound {
  (...)
  bool _loaded_sound; // O som já foi carregado?
  ALuint buffer; // Referencia buffer com conteúdo sonoro
};
\alinhanormal

Nossa missão será preencher o buffer OpenAL presente nesta
estrutura. E quando terminarmos, devemos mudar para ``verdadeiro'' o
valor da variável booleana acima. Isso indica para o motor de jogos
que o som já pode ser usado.

O buffer é preenchido pela função de carregamento quando ela lê o
arquivo \monoespaco{source\_filename}, a qual deverá ser um arquivo no
formato WAVE.

A função de carregamento também tem a obrigação de executar a função
\monoespaco{before\_loading\_interface} antes de começar qualquer
outra atividade. O que tal função faz, não nos diz respeito. O motor
de jogos Weaver realiza ações relevantes para ele quando a função é
executada. Depois que o arquivo é carregado, ou mesmo se ele não puder
ser carregado devido a um erro, também temos a obrigação de executar a
função \monoespaco{after\_loading\_interface}, cujo efeito não nos diz
respeito. Caso qualquer uma destas funções seja NULL, então ela não
precisa ser executada.

Os outros argumentos recebidos pela função de extração são para
alocação e desalocação de dados. Devemos distinguir uma alocação entre
temporária e permanente. Uma alocação permanente é para dados que
precisam estar ativos mesmo depois que a função de extração
executar. Já a alocação temporária é para dados necessários somente
enquanto lemos o arquivo. Cada função de alocação tem uma de
desaloicação correspondente. Mas a função de desalocação pode ser
NULL. Em tal caso, nós não a usaremos e apenas assumiremos existir
algum tipo de coleta automática de lixo.

Como as funções de alocação e desalocação poderão ser necessárias em
muitas outras funções auxiliares, não apenas a de extração, vamos
armazenar elas em variáveis estáticas globais. Caso os valores não
tenham sido inicializados, usaremos as funções padrão de alocação e
desalocação da biblioteca padrão.

@<Variáveis Locais (wave.c)@>=
static void *(*permanent_alloc)(size_t) = malloc;
static void *(*temporary_alloc)(size_t) = malloc;
static void (*permanent_free)(void *) = free;
static void (*temporary_free)(void *) = free;
@

\subsecao{1.1. Programação Literária}

Nossa API será escrita usando a técnica de Programação Literária,
proposta por Knuth em [KNUTH, 1984]. Ela consiste em escrever um
programa de computador explicando didaticamente em texto o que se está
fazendo à medida que apresenta o código. Depois, o programa é
compilado através de programas que extraem o código diretamente do
texto didático. O código deve assim ser apresentado da forma que for
mais adequada para a explicação no texto, não como for mais adequado
para o computador.

Seguindo esta técnica, este documento não é uma simples documentação
do nosso código. Ele é por si só o código. A parte que será extraída e
compilada posteriormente pode ser identificada como sendo o código
presente em fundo cinza. Geralmente começamos cada trecho de código
com um título que a nomeia. Por exemplo, imediatamente antes desta
subseção nós apresentamos uma série de declarações. E como pode-se
deduzir pelo título delas, a maioria será posteriormente posicionada
dentro de um arquivo chamado \monoespaco{interface.h}.

Podemos apresentar aqui a estrutura do arquivo \monoespaco{wave.h}:


@(src/wave.h@>=
#ifndef __WEAVER_INTERFACE_WAVE
#define __WEAVER_INTERFACE_WAVE
#ifdef __cplusplus
extern "C" {
#endif
#include <stdbool.h> // Define tipo 'bool'
@<Declaração de Função (wave.h)@>
#ifdef __cplusplus
}
#endif
#endif
@

O código acima mostra a burocracia padrão para definir um cabeçalho
para nossa API em C. As duas primeiras linhas mais a última são macros
que garantem que esse cabeçalho não será inserido mais de uma vez em
uma mesma unidade de compilação. As linhas 3, 4, 5, assim como a
penúltima, antepenúltima e a antes da antepenúltima tornam o cabeçalho
adequado a ser inserido em código C++. Essas linhas apenas avisam que
o que definirmos ali deve ser encarado como código C. Por isso o
compilador está livre para fazer otimizações sabendo que não usaremos
recursos da linguagem C++, como sobrecarga de operadores. Logo em
seguida, inserimos um cabeçalho que nos permite declarar o tipo
booleano. E tem também uma parte em vermelha. Note que uma delas é
``Declaração de Função (wave.h)'', o mesmo nome apresentado no trecho de
código mostrado quando descrevemos nossa API antes dessa
subseção. Isso significa que aquele código visto antes será depois
inserido ali. As outras partes em vermelho representam código que
ainda iremos definir nas seções seguintes.

Caso queira observar o que irá no arquivo \monoespaco{wave.c}
associado a este cabeçaho, o código será este:


@(src/wave.c@>=
#include "wave.h"
@<Cabeçalhos Locais (wave.c)@>
@<Variáveis Locais (wave.c)@>
//@<Funções Auxiliares Locais (interface.c)@>
//@<Definição de Funções da API (interface.c)@>
@


Todo o código que definiremos e explicaremos a seguir será posicionado
nestes dois arquivos. Além deles, nenhum outro arquivo será criado.

\secao{2. O Formato RIFF}

Todo arquivo WAVE é também um arquivo no formato RIFF. Então é útil
começar analizando como um arquivo RIFF é organizado.

Primeiro que todo arquivo RIFF é um conjunto de ``pedaços'', ou
``chunks''. Em todo arquivo do tipo há 1 ou mais pedaços.

Cada pedaço é composto por três partes: 4 bytes (tipicamente
caracteres) identificando o tipo do pedaço, 4 bytes identificando o
tamanho dos dados do pedaço, e mais uma sequência de bytes com o
tamanho indicado representando os dados. Os dados também podem ter
bytes finais de preenchimento caso eles sejam um pouco menores que o
tamanho indicado.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\secao{Referências}

\referencia{Knuth, D. E. (1984) ``Literate Programming'', The Computer
  Journal, Volume 27, Edição 2, Páginas 97--111.}

\fim
